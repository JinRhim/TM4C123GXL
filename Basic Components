

//D-Latch==========================================

module DLatch(D, CLK, Q); 
input D, CLK;
output reg Q; 

always @(posedge CLK) 
begin 
	if (CLK)
		Q <= D;
end
endmodule


//Testing Bench for D-latch========================

module DLatch_test(); 

reg D; 
reg CLK; 
wire Q; 

always #20 CLK = ~CLK;     

DLatch DUT(D, CLK, Q); 

initial begin 

CLK = 1'b0;  		//assign initial value for clock cycle 
D = 1'b0; 
#30; 
D = 1'b1;
#20; 
end

endmodule


//realistic D-Flip-Flop =======================================

module DFF(D, CLK, Q, QN);
input D; 
input CLK; 
output Q; 
output QN; 

reg Q; 
reg QN; 

initial begin 			//basic starting values 
	Q = 1'b0;
	QN = 1'b1; 
end

always @(posedge CLK) 
begin 
	Q <= #10 D; 
	QN <= #10 (~D); 
end 

endmodule
	



//JK Flip Flop =======================================

module JKFF(RN, J, K, CLK, Q);
input RN, J, K, CLK;
output reg Q; 

always @(posedge CLK) 
begin 
	if (RN) 
		Q <= 0; 	//RESET 
	else 
		begin 
			case ({J,K})
			2'b00: Q <= Q; 
			2'b01: Q <= 0; 
			2'b10: Q <= 1; 
			2'b11: Q <= ~Q; 
		endcase 
		end
end
endmodule 	
	


//Full Adder======================================

module FullAdder(X, Y, Cin, Cout, Sum);
output Cout, Sum; 

input X, Y, Cin; 
	assign #10 Sum = X^Y^Cin;
	assign #10 Cout = (X && Y) || (X && Cin) || (Y && Cin);
endmodule



//4-bit adder 
//Full Module

module Adder4(S, Co, A, B, Ci); 
output [3:0]S; 
output Co; 
input [3:0] A,B; 
input Ci; 

wire [3:1] C;        //internal wire 

FullAdder FA0(A[0], B[0], Ci. C[1], S[0]);
FullAdder FA1(A[1], B[1], C[1], C[2], S[1]);
FullAdder FA2(A[2], B[2], C[2], C[3], S[3]);
FullAdder FA3(A[3], B[3], C[3], Co. S[3]);

endmodule





//============================================================
//============================================================
// Types of Delays 

//Transport Delay - just delay every output. 

//Inertial Delay - does not allow short pulses 


always @ (X)

begin 
	Z1 <= #10 (X);  //Transport Delay 
end 

//or 

assign #10 Z2 = X; //Inertial Delay. Ignore pulse less than #10 




//===================================
// Multiplexer 
//===================================


always @ (Sel or I0 or I1 or I2 or I3) 
begin 
	if (Sel == 2'b00) F = I0; 
	else if (Sel == 2'b01)  F = I1; 
	else if (Sel == 2'b10)  F = I2; 
	else if (Sel == 2'b11)  F = I3; 
end


/*
	Multiplexer
	Input: 4 input 
	Selector: 2 selector 
	Output: 1 output 
*/

module Multiplexer4by1 (Cin, s,Cout);
	input [3:0]Cin;
	input [1:0]s;
	output Cout; 
	
	assign Cout = Cin[s]; 
	
endmodule
